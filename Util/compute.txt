Модуль для вычисления формул в текстовых редакторах (строковый калькулятор) и калькуляторов.
К стандартным функциям, введенным Антоном Григорьевым (Черноголовка) в SaveCalc, добавлены новые функции, а также введена возможность использования альтернативных имен, принятых в отечественной, европейской и американской литературе. 

И.Л.Андронов

Входит в комплект старого дистрибутива текстового редактора Bred2i
http://andronov.astronomy.org.ua/soft/Bred2i.rar
http://www.paco.net/~il-a/Bred2i.rar
http://il-a.pochta.ru/Bred2i.rar - К сожалению, почему-то копируется в сбойном виде...

В новой версии, по многочисленным просьбам пользователей NT/2000/XP,  где DLL "терялась",
строковый калькулятор включен в единый EXE - файл B.EXE, доступный через
http://www.softodrom.ru/win/p4726.shtml
До появления Final версии Bred2 плагин в новых дистрибутивах недоступен, но функции используются в Bred2.

Этот плагин может быть использован и для других текстовых редакторов (в TEA версии 3.26 его надо просто скопировать в папку Plugins).
Для других редакторов придется давать обьявление
   function HandleData (h:integer; var val:PChar):integer; far;external 'compute_';
передавать выделенный текст в PChar в эту функцию, и в таком же виде брать обратно.
Значение самой функции равно 0 при нормальном завершении.
Смысл h:integer остается неясным, но я этот плагин делал в формате TEA, и под него же
вызов в Bred подстраивал :). Сам файл compute_.dll надо скопировать в ту же папку, что
и саму программу B.Exe . Для вызова выделите текст с формулой, нажмите Alt+C, и 
получите результат (если формула без ошибок набора), напр.
sin(pi/4)=0.707106781186547.

Хочу выразить благодарность Петру Семилетову (www.roxton.kiev.ua) за полезные обсуждения.
На его сайте приведены тестовый редактор TEA (для Win и UNIX), записная книжка XLAM
и другие полезные программы.

unit SaveCalc0;
//Список функций модуля SaveCalc0 (Григорьев Антон, Черноголовка)
//модифицирован 04.04.2004 (Андронов Иван, Одесса, http://il-a.pochta.ru, oap11@pochtamt.ru)
//в скобках указаны только аргументы, по числу превышающие 1
//Для некоторых функций сохранены два или даже три обозначения, принятые в отечественной,
//европейской и американской математической литературе
//Аргументы тригонометрических выражений выражаются в радианах

//COS   Косинус
//SQRT , S   Квадратный корень
//SIN   Синус
//SINC   функция Шеннона = sin(pi*x)/(pi*x)
//TG, TAN   Тангенс
//ARCCOS   Арккосинус
//ARCSIN   Арксинус
//ARCTG, ARCTAN, ATN   Арктангенс
//FIBONACCI, FI   Число Фибоначчи 1,2,3,5,8... Fi_n=Fi_(n-1)+Fi_(n-2)
//ERF Интеграл вероятностей erfc(x)=int(exp(-v*v)*2/sqrt(pi),v,0,x)
//ERFC дополнительный интеграл вероятностей erfc(x)=int(exp(-v*v)*2/sqrt(pi),v,x,infinity)
//FACT факториал x! (аргумент усекается до целого, для отрицательных аргументов функция не определена)
//FAC1  1/x! (отдельно, чтобы избежать ошибки переполнения для больших аргументов)
//FACL ln(x!) логарифм факториала (это позволяет избежать переполнения при больших аргументах)
//EXP, E   Экспонента
//DEX, D   десятичная экспонента (десять в степени) - есть в новом Bred2,  но не в DLL.
//LN    Натуральный логарифм
//LG, LOG10  Десятичный логарифм
//CTG, COTAN   Котангенс
//SQR   Возведение в квадрат
//LOG(x,y)   Логарифм с произвольным основанием log_x(y)
//POWER(x,y), POW(x,y), P(x,y)  Возведение в степень x^y
//C(n,k) Биномиальные коэффициенты C(n,k)=n!/(k!(n-k)!), k=0..n 
//CLN(n,k) логарифмы Биномиальных коэффициентов ln(C(n,k))
//ATAN2(y,x) Арктангенс от двух аргументов (r*sin f, r*cos f) с выбором четверти (-pi,pi) для ATAN2
//ARCTG2(y,x) Арктангенс от двух аргументов (r*sin f, r*cos f) с выбором четверти (0,2*pi) для ARCTG2
//ABS Модуль числа
//SH, SINH Гиперболический синус
//CH, COSH Гиперболический косинус
//TH, TANH Гиперболический тангенс
//ARSH, ARCSINH  Гиперболический Арксинус
//ARCH,ARCCOSH   Гиперболический Арккосинус
//ARTH,ARCTANH   Гиперболический Арктангенс
//SGN Знак (сигнум) числа (-1 при x<0; 0 при x=0; 1 при x>0)
//SUM(i1,i2,function(i))  Сумма нескольких слагаемых, суммирование по индексу i.
//            В обычной записи соответствует  греческой большой букве "сигма".
//            Первый параметр - начальное значение индекса, второй - конечное, третий -
//            суммируемое выражение, может зависеть от i
//            границы изменения параметра усекаются (trunc) до целого числа.
//            Например,  sum(0,5,pow(0.1,i)*pow(0.9,5-i)*fact(5)/fact(i)/fact(5-i)) равно 1
//MAX(x_1,..,x_N) Максимальное значение из списка. Число элементов в списке произвольно, но не меньше одного.
//MIN(x_1,..,x_N)   Минимальное значение из списка
//IF(boolean,result1(true),result2(false))  Очень полезная функция, к сожалению не реализованная в Delphi.
//          Имеет три аргумента: первый - логическое выражение, два других - числовые.
//          Если логическое выражение истинно, функция возвращает значение второго параметра, если нет - третьего.

//константы
PI=3.14159265358979
GOLD=(sqrt(5)-1)/2=0.618033988749895 отношение "золотого сечения" x/y=y/(x+y)
AU=1.496e9 м (астрономическая единица, среднее расстояние от Земли до СОлнца)
MS=1.989e30 кг - масса Солнца,
RS=6.96e8 м - радиус Солнца,
LS=3.826e26 Ватт- светимость Солнца,
L0=2.97e28 Ватт - светимость при абсолютной болометрической звездной величине Mbol=0,
CC=2.997925e8 м/c - скорость света (однобуквенные константы не используются)
GG=6.670e-11 - гравитационная постоянная
HH=6.6262e-34 дж*сек - постоянная Планка
ME=9.10956e-31 кг - масса электрона
MP=1.672661e-27 кг - масса протона {proton's mass}
SB=5.66956e-8 постоянная Стефана-Больцмана
PC=3.0857e16 м - парсек - расстояние, к которого радиус земной орбиты виден перпендикулярно, под углом 1 секунда дуги.
KK=1.38062e-23 Дж/градус, постоянная Больцмана
RR=8.3143 Дж/(град*моль), газовая постоянная.


//Планируемые добавления-
//специальные функции (Бесселя, Чебышева, Лягерра, Якоби, Вейерштрасса и др)
//генератор случайных чисел с заданным законом распределения (равномерное, нормальное, Пуассона, биномиальное, Бернулли, Хи квадрат, гамма, бета, Фишера, гипергеометрическое, экспоненциальное, Коши, арксинуса итд.)
//усовершенствование парсера на распознавание факториала ! и возвездение в степень x^y
//функции для работы с целыми числами - разложение на множители Factorize, наибольший общий делитель LCD (largest common divisor), наименьшее общее кратное (smallest common)

//Enjoy!


Комментарии в исходном тексте Антона Григорьева:

{  Алгоритм вычисления выражений (мне его рассказал Копылов Павел Николаевич, наш
   школьный учитель информатики)

   В дальнейшем, если специально не оговорено обратное, для краткости под операцией
   сложения подразумевается операция сложения или вычитания, под операцией умножения -
   операция умножения или деления. Операции из каждой этой пары имеют одинаковый
   приоритет, поэтому при анализе выражения нет смысла различать их. Соответствующий
   смысл приобретают слова "слагаемое" и "множитель".

   Элементарной единицей выражения является множитель (multiplier). Множителем называется
   число, переменная, функция или выражение в скобках. Последовательность множителей,
   соединённых знаками умножения, называется слагаемым (addend). Последовательность
   слагаемых, соединённых знаками сложения - выражением (expression). Легко заметить, что
   эти определения рекурсивны, то есть для определения понятия "выражение" требуется
   определить понятие "множитель", одна из возможных форм которого - выражение в скобках.
   Кроме того, аргумент функции также является выражением. Это предопределяет способ
   реализации алгоритма. Обратите внимание, что определения множителей и слагаемых даны
   "с другого конца". Обычно сначала определяется операция (например, сложения), а потом
   её опреанды называются слагаемыми. В нашем случае сначала определяется, что такое
   слагаемое, а затем операцией сложения называется та операция, которая связывает их
   между собой. Это существенно для понимания алгоритма, потому что при анализе
   выражения первичным является распознавание и классификация множителей по типу,
   вторичным - объединение их в слагаемые, и на третьем месте - окончательное вычисление
   выражение (т.е. сложение этих самых слагаемых). Важно, что на самом деле это деление
   на первичное, вторичное и третичное существенно именно для понимания алгоритма работы:
   по времени эти операции не разделены.

   Все функции имеют параметр-переменную P типа Integer. При вызове в ней содержится
   номер символа строки, с которого надо начинать анализ. Функция анализирует свою
   часть строки и передвигает этот указатель дальше.

   Ключевой функцией является функция Multiplier, выделяющая из строки множитель. Она
   просматривает строку, начиная с заданной параметром P позиции, и определяет тип
   множителя (число, переменная...) и место, где он заканчивается. Множители объединяются
   функцией Addend в слагаемые, слагаемые - функцией Expr в выражения. Функция Func
   предназначена для опознания известных математических функций.

   Допустимыми именами переменных являются буквы латинского алфавита. Имена, состоящие
   из двух и более букв, не допускаются (впрочем, это не так уж сложно сделать при
   необходимости). Значения переменных хранятся в массиве Variables.

   Функции имеют не менее одного параметра. Параметры разделяются запятыми. В принципе
   возможно переменное число параметров.

   Есть ещё один тип множителя - константа PI. Она не относится ни к переменным, ни к
   функциям, что легко видеть, просмотрев код.

   Рассмотрим работу функции Addend. Она работает с отдельным слагаемым. Любое слагаемое
   состоит хотя бы из одного множителя. Поэтому прежде всего вызывается функция Multiplier,
   вычисляющая значение этого множителя и перемещающая указатель P на первый символ
   после этого множителя. Далее проверяется, является ли этот символ символом умножения.
   Если да, то вычисляется следующий множитель и перемножается с предыдущим. Если нет -
   функция завершает свою работу. Эта операция повторяется в цикле. Аналогично работает
   функция Expr.

   К обычному набору функций добавлена функция if, требующая вычисления логических
   выражений. Логическим выражением называется выражение вида A#B или A%B%C, где вместо
   '#' может стоять '<', '>', '=', '>=', '<=', '<>', а вместо '%' - '<' или '<='. A, B и C -
   числовые выражения. Вычисление логических выражений реализуется функцией BoolExpr.

   Все вышеперечисленные функции описаны в разделе реализации модуля. Вызывающая программа
   общается с ними через функцию CalcStr. Эта функция добавляет к строке пробел, прежде
   чем начать вычислять её. Без этого пробела приходилось бы постоянно сравнивать
   значение указателя P и длину строки S, иначе после полного анализа строки значение
   указателя будет равно Length(S)+1, и обращение S[P] приведёт к ошибке. Пробел же не
   является допустимым символом, поэтому каждая из функций, встретив его, прекращает
   работу, передавая управление "вышестоящей инстанции". Для функции Expr такой
   инстанцией является CalcStr, и передача управления в эту функцию сигнализирует о
   завершении трансляции строки.

   В заключение добавлю, что полностью аналогичный алгоритм можно использовать не только
   для вычисления выражений, но и, например, для их символьного дифференцирования. Только
   при дифференцировании встаёт ещё задача об упрощении получившегося выражения, потому
   что производная, например, функции 'x*x*x' будет иметь вид '1*x*x+x*(1*x+x*1)'. Это,
   безусловно, правильно, но уж больно коряво.

   Другой путь модификации этого алгоритма - превращение его из интерпретатора в
   компилятор. Это может оказаться полезным, например, при построении графиков, когда
   приходится часто вычислять значение одного выражения при разных значениях одной или
   нескольких переменных. Переход от интерпретации к компиляции - вещь вполне реальная,
   хоть и муторная: в своё время мне удалось написать такой модуль для Delphi 3.0. Однако
   такой компилятор может перестать работать в будущих версиях Delphi, если изменится,
   например, модель вызова. А этот транслятор использует только те возможности Delphi,
   которые полностью документированы и поддержка которых в следующих версиях
   гарантируется производителями продукта. Вам выбирать - скорость или переносимость.

                                                      Григорьев Антон, Черноголовка

}

